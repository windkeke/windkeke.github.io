<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>卡尔曼滤波</title>
    <url>/2020/09/22/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h2 id="一、背景—卡尔曼滤波的意义"><a href="#一、背景—卡尔曼滤波的意义" class="headerlink" title="一、背景—卡尔曼滤波的意义"></a><strong>一、背景—卡尔曼滤波的意义</strong></h2><p>随着传感技术、机器人、自动驾驶以及航空航天等技术的不断发展，对控制系统的精度及稳定性的要求也越来越高。卡尔曼滤波作为一种状态最优估计的方法，其应用也越来越普遍，如在无人机、机器人等领域均得到了广泛应用。</p>
<p>对于Kalman Filter的理解，用过的都知道“<strong>黄金五条</strong>”公式，且通过“<strong>预测</strong>”与“<strong>更新</strong>”两个过程来对系统的状态进行最优估计，但完整的推导过程却不一定能写出来，希望通过此文能对卡尔曼滤波的原理及状态估计算法有更一步的理解。</p>
<p><img src="https://pic3.zhimg.com/v2-ab8d431a2b60b016557e11f21dc373db_b.jpg" alt="img"></p>
<a id="more"></a>

<h2 id="二、卡尔曼滤波的基本模型"><a href="#二、卡尔曼滤波的基本模型" class="headerlink" title="二、卡尔曼滤波的基本模型"></a><strong>二、卡尔曼滤波的基本模型</strong></h2><p>假设一离散<strong>线性动态系统</strong>的模型如下所示：</p>
<p><img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D+%3D+A%2Ax_%7Bk-1%7D+%2B+B%2Au_%7Bk%7D+%2B+w_%7Bk-1%7D" alt="[公式]">)——-(1)</p>
<p><img src="https://www.zhihu.com/equation?tex=z_%7Bk%7D+%3D+H%2Ax_%7Bk%7D+%2B+v_%7Bk%7D" alt="[公式]"> ——————–(2)</p>
<p>其中，各变量表征的意义为：</p>
<p>———————————————————————————</p>
<p><img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D%5CRightarrow" alt="[公式]"> 系统状态矩阵，——-， <img src="https://www.zhihu.com/equation?tex=z_%7Bk%7D%5CRightarrow" alt="[公式]"> 状态阵的观测量（实测）</p>
<p><img src="https://www.zhihu.com/equation?tex=A%5CRightarrow" alt="[公式]"> 状态转移矩阵 ，——-， <img src="https://www.zhihu.com/equation?tex=B%5CRightarrow" alt="[公式]"> 控制输入矩阵</p>
<p><img src="https://www.zhihu.com/equation?tex=H%5CRightarrow" alt="[公式]"> 状态观测矩阵</p>
<p><img src="https://www.zhihu.com/equation?tex=w_%7Bk-1%7D%5CRightarrow" alt="[公式]"> 过程噪声，——-， <img src="https://www.zhihu.com/equation?tex=v_%7Bk%7D%5CRightarrow" alt="[公式]"> 测量噪声</p>
<p>———————————————————————————</p>
<p>如果大家学过《现代控制理论》的话，对上述模型的描述形式一定不会陌生，只是多了变量 <img src="https://www.zhihu.com/equation?tex=w_%7Bk-1%7D" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=v_%7Bk%7D" alt="[公式]"> 。其中，随机变量<img src="https://www.zhihu.com/equation?tex=w_%7Bk-1%7D" alt="[公式]"> 代表过程噪声（<em>process noise</em>）， <img src="https://www.zhihu.com/equation?tex=v_%7Bk%7D" alt="[公式]"> 代表测量噪声（<em>measurement noise</em>），且为<strong>高斯白噪声</strong>，协方差分别为 <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=R" alt="[公式]"> ，即 <img src="https://www.zhihu.com/equation?tex=p%28w%29+%5Cin+N%280%2CQ%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=p%28v%29+%5Cin++N%280%2CR%29" alt="[公式]"> 。</p>
<p><strong>为什么要引入这两个变量呢？</strong></p>
<p>对于大多数实际的控制系统（如倒立摆系统）而言，它并不是一个严格的线性时变系统(Linear Time System)，亦或系统结构参数的不确定性，导致估计的状态值 <img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D" alt="[公式]"> 存在偏差，而这个偏差值由过程噪声 <img src="https://www.zhihu.com/equation?tex=w_%7Bk%7D" alt="[公式]"> 来表征。对于状态观测方程——(2)而言，我们知道采集的信号往往是包含噪声及干扰信号的，亦或观测矩阵<img src="https://www.zhihu.com/equation?tex=H" alt="[公式]"> 自身的观测偏差，从而导致了测得的实际信号（观测值）与真实值之间存在一定的偏差，这个量由 <img src="https://www.zhihu.com/equation?tex=v_%7Bk%7D" alt="[公式]"> 来表征。</p>
<p><img src="https://pic4.zhimg.com/v2-903444dc0a8aa3abeeaec5e5d97ef3dd_b.jpg" alt="img"></p>
<h2 id="三、Kalman-Filter的公式推导"><a href="#三、Kalman-Filter的公式推导" class="headerlink" title="三、Kalman Filter的公式推导"></a><strong>三、Kalman Filter的公式推导</strong></h2><p>对于状态估计算法而言，我们可以获取状态量的三个值：<strong>状态预测值</strong>（ <img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D%5E%7B-%7D" alt="[公式]"> ）、<strong>最优估计值</strong>（ <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D" alt="[公式]"> ）以及<strong>真实值</strong>（ <img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D" alt="[公式]"> ），卡尔曼滤波的原理就是利用卡尔曼增益来修正状态预测值，使其逼近真实值。</p>
<p>为使其便于理解，对卡尔曼滤波的推导过程，第一个过程分为状态估计协方差 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D" alt="[公式]"> 的推导，即代价函数的求取；第二步则是卡尔曼增益矩阵及其他准则的推导。</p>
<h2 id="3-1-状态估计协方差"><a href="#3-1-状态估计协方差" class="headerlink" title="3.1 状态估计协方差 "></a>3.1 状态估计协方差 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D" alt="[公式]"></h2><p>在对状态估计协方差 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D" alt="[公式]"> 求取之前，先介绍状态估计算法中关于系统状态矩阵的几种表示：</p>
<p>——————————————————————————————————</p>
<p><img src="https://www.zhihu.com/equation?tex=x_%7Bk%7D%5CRightarrow" alt="[公式]"> 状态的真实值；</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%5CRightarrow" alt="[公式]"> 状态的预测值，也称先验状态估计值（a prior state estimate）；</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%5CRightarrow" alt="[公式]"> 状态的最优估计值，也称后验状态估计值（a posteriori state estimate）；</p>
<p>——————————————————————————————————</p>
<ul>
<li>状态预测值 <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D" alt="[公式]"> 由<strong>状态预测方程</strong>可得：<strong>黄金1条</strong></li>
</ul>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D+%3D+A%2A%5Ctilde%7Bx%7D_%7Bk-1%7D+%2B+B%2Au_%7Bk%7D" alt="[公式]">    ——–(3)</p>
<ul>
<li>状态最优估计值 <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D" alt="[公式]"> 可由<strong>状态更新方程</strong>可得：<strong>黄金2条</strong>  </li>
</ul>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%3D%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%2BK%28z_%7Bk%7D-H%2A%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%29" alt="[公式]">  —–(4)</p>
<p>通过该方程可知，卡尔曼增益 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 实际上表征了状态最优估计过程中模型预测误差（<em>Predicted error</em>）与量测误差（<em>Measurement error</em>）的比重（如下所示），即 <img src="https://www.zhihu.com/equation?tex=K%5Cin%5B0%2C+1%5D" alt="[公式]"> 。当 <img src="https://www.zhihu.com/equation?tex=K%3D0" alt="[公式]"> 时，即预测误差为0，系统的状态值完全取决与预测值（ <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%3D%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D" alt="[公式]"> ）；而当 <img src="https://www.zhihu.com/equation?tex=K%3D1" alt="[公式]"> 时，即量测误差为0，系统的状态值完全取决于量侧值。</p>
<p><img src="https://www.zhihu.com/equation?tex=K%3D" alt="[公式]"> <strong><em>Predicted error/ (Predicted error + Measurement error)</em></strong></p>
<p>因此，可令：</p>
<ul>
<li><img src="https://www.zhihu.com/equation?tex=e_%7Bk%7D%5E%7B-%7D+%3D+x_%7Bk%7D-%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D" alt="[公式]">  —————(5)</li>
<li><img src="https://www.zhihu.com/equation?tex=e_%7Bk%7D%3Dx_%7Bk%7D-%5Ctilde%7Bx%7D_%7Bk%7D" alt="[公式]">   —————(6)</li>
<li><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%5E%7B-%7D+%3DE%5B+e_%7Bk%7D%5E%7B-%7D%2Ae_%7Bk%7D%5E%7B-%7D%7B%7D%5E%7BT%7D%5D" alt="[公式]"> ———–(7)</li>
<li><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%3DE%5B+e_%7Bk%7D%2Ae_%7Bk%7D%5E%7BT%7D%5D" alt="[公式]"> ————–(8) </li>
</ul>
<p>其中：</p>
<p>—————————————————————————</p>
<p><img src="https://www.zhihu.com/equation?tex=e_%7Bk%7D%5E%7B-%7D%5CRightarrow" alt="[公式]"> 先验状态误差</p>
<p><img src="https://www.zhihu.com/equation?tex=e_%7Bk%7D%5CRightarrow" alt="[公式]"> 后验状态误差</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%5E%7B-%7D%5CRightarrow" alt="[公式]"> 真实值与预测值之间的协方差</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%5CRightarrow" alt="[公式]"> 真实值与最优估计值之间的协方差</p>
<p>—————————————————————————</p>
<p>由方程(2)(4)可知，</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%3D%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%2BK%28H%2Ax_%7Bk%7D%2Bv_%7Bk%7D-H%2A%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%29" alt="[公式]"> ——–(9)</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D%3D%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%2BKH%2Ax_%7Bk%7D-KH%2A%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%2BKv_%7Bk%7D" alt="[公式]"> ——(10)</p>
<p><strong>变换后的方程，</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bx%7D_%7Bk%7D-x_%7Bk%7D%3D%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D-x_%7Bk%7D%2BKH%28x_%7Bk%7D-%5Ctilde%7Bx%7D_%7Bk%7D%5E%7B-%7D%29%2BKv_%7Bk%7D" alt="[公式]">)—(11)</p>
<p>联立方程(5)(6)可知，</p>
<p><img src="https://www.zhihu.com/equation?tex=e_%7Bk%7D+%3D+%28I-KH%29%2Ae_%7Bk%7D%5E%7B-%7D-K%2Av_%7Bk%7D" alt="[公式]">)—————–(12)</p>
<p>因此，由方程(8)可知估计误差方差阵 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D" alt="[公式]"> 为：</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%3DE%5B+e_%7Bk%7D%2Ae_%7Bk%7D%5E%7BT%7D%5D%3D%28I-KH%29%2AP_%7Bk%7D%5E%7B-%7D%2A%28I-KH%29%5E%7BT%7D%2BK%2AR%2AK%5E%7BT%7D" alt="[公式]"> —(13)</p>
<p><strong>展开可知</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%3DP_%7Bk%7D%5E%7B-%7D-KHP_%7Bk%7D%5E%7B-%7D-P_%7Bk%7D%5E%7B-%7DH%5E%7BT%7DK%5E%7BT%7D%2BK%28HP_%7Bk%7D%5E%7B-%7DH%5E%7BT%7D%2BR%29K%5E%7BT%7D" alt="[公式]"> ——–(14)</p>
<h2 id="3-2-状态变量"><a href="#3-2-状态变量" class="headerlink" title="3.2 状态变量"></a>3.2 状态变量</h2><p>卡尔曼滤波的估计原则就是使最优状态估计的协方差 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D" alt="[公式]"> 最小，使其越来越逼近于真实值。因此，其<strong>目标函数为：</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=J%3D%5Csum_%7Bmin%7D%7BP_%7Bk%7D%7D" alt="[公式]"> ———————–(15)</p>
<p>对卡尔曼增益矩阵<img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 求偏导，不难可知：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%7BP_%7Bk%7D%7D%7D%7B%5Cpartial+%7BK%7D%7D%3D-2%28P_%7Bk%7D%5E%7B-%7DH%5E%7BT%7D%29%2B2K%28HP_%7Bk%7D%5E%7B-%7DH%5E%7BT%7D%2BR%29%3D0" alt="[公式]">)—-(16)</p>
<p>由此可知最优估计条件下的卡尔曼增益矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 为—–<strong>黄金三条</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=K%3DP_%7Bk%7D%5E%7B-%7DH%5E%7BT%7D%28HP_%7Bk%7D%5E%7B-%7DH%5E%7BT%7D%2BR%29%5E%7B-1%7D" alt="[公式]">)—-(17)  </p>
<p>联立式(11)(14)即可知道估计误差方差阵为———–<strong>黄金四条</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%3D%28I-KH%29%2AP_%7Bk%7D%5E%7B-%7D" alt="[公式]"> ———-(18)</p>
<p>黄金5条的最后一条的状态估计协方差 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%7D%5E%7B-%7D" alt="[公式]"> ，由式（5）可知：</p>
<p><img src="https://www.zhihu.com/equation?tex=e_%7Bk%2B1%7D%5E%7B-%7D+%3D+x_%7Bk%2B1%7D-%5Ctilde%7Bx%7D_%7Bk%2B1%7D%5E%7B-%7D++++++++++++++++++++%3D%28A%2Ax_%7Bk%7D%2BBu_%7Bk%7D%2Bw_%7Bk%7D%29-%28A%2A%5Ctilde%7Bx%7D_%7Bk%7D%2BBu_%7Bk%7D%29" alt="[公式]"> </p>
<p>化简可知： <img src="https://www.zhihu.com/equation?tex=e_%7Bk%2B1%7D%5E%7B-%7D%3DA%28x_%7Bk%7D-%5Ctilde%7Bx%7D_%7Bk%7D%29%2Bw_%7Bk%7D%3DAe_%7Bk%7D%2Bw_%7Bk%7D" alt="[公式]"> </p>
<p>由式（7）可知：</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%2B1%7D%5E%7B-%7D+%3DE%5B+e_%7Bk%2B1%7D%5E%7B-%7D%2Ae_%7Bk%2B1%7D%5E%7B-%7D%7B%7D%5E%7BT%7D%5D%3DE%5B%28Ae_%7Bk%7D%2Bw_%7Bk%7D%29%28Ae_%7Bk%7D%2Bw_%7Bk%7D%29%5E%7BT%7D%5D" alt="[公式]"> —–(19)</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%2B1%7D%5E%7B-%7D%3DE%5B%28Ae_%7Bk%7D%29%28Ae_%7Bk%7D%29%5E%7BT%7D%5D%2BE%5Bw_%7Bk%7D%28w_%7Bk%7D%29%5E%7BT%7D%5D" alt="[公式]"> ——————–(20)</p>
<p>由式（20）不难得知，预测协方差矩阵 <img src="https://www.zhihu.com/equation?tex=P_%7Bk%2B1%7D%5E%7B-%7D" alt="[公式]"> 为：—<strong>黄金5条</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bk%2B1%7D%5E%7B-%7D%3DAP_%7Bk%7DA%5E%7BT%7D%2BQ" alt="[公式]"> ———–(21)</p>
<p>至此，卡尔曼滤波的黄金5条全部推导完成，其“状态预测”与“状态更新”过程如下图所示。</p>
<p><img src="https://pic4.zhimg.com/v2-32b046b882950eac20eda2c502f4e005_b.jpg" alt="img"></p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a><strong>四、小结</strong></h2><p>卡尔曼滤波作为一种状态最优估计算法，与《现代控制系统》中的<strong>观测器设计</strong>思维类似，都是利用观测量并结合系统的模型来对系统的状态进行估计。但二者又有不同，由前面的介绍可知卡尔曼滤波的目的是利用卡尔曼增益来修正状态预测值，而观测器设计的目的是当系统的有些状态信息无法有效获取或不易测得时，通过状态重构，以便实现反馈控制。</p>
<p>参考文献</p>
<p>[1] <a href="www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf">An Introduction to the Kalman Filter - UNC Computer Science</a></p>
<p>[2] <a href="https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">How a Kalman filter works, in pictures</a></p>
<p>[3] <a href="https://towardsdatascience.com/kalman-filter-interview-bdc39f3e6cf3" target="_blank" rel="noopener">Harveen Singh, Kalman Filter Interview</a></p>
<p>[4] <a href="web.mit.edu/kirtley/kirtley/binlustuff/literature/control/Kalman%20filter.pdf">Tutorial: The Kalman Filter, MIT</a></p>
]]></content>
      <categories>
        <category>雷达处理算法</category>
      </categories>
      <tags>
        <tag>Radar Process Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>从SDK构建IWR1443驱动程序</title>
    <url>/2020/05/12/%E4%BB%8ESDK%E6%9E%84%E5%BB%BAiwr1443%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="首先新建一个CCS工程"><a href="#首先新建一个CCS工程" class="headerlink" title="首先新建一个CCS工程"></a>首先新建一个CCS工程</h1><ul>
<li>选择目标型号IWR1443，并且在下面选择新建一个SYS/BIOS工程，点击Next</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511170144511.png" alt="image-20200511170144511"></p>
<a id="more"></a>
<ul>
<li>勾选mmWave SDK与SYS/BIOS版本</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511170237202.png" alt="image-20200511170237202"></p>
<ul>
<li>可以看到新建的工程中已经包含了<code>main.c</code>源文件与<code>app.cfg</code>配置文件，下一步将代码文件改为自己的驱动源码。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511170658370.png" alt="image-20200511170658370"></p>
<h1 id="更改源码文件，编译调试错误"><a href="#更改源码文件，编译调试错误" class="headerlink" title="更改源码文件，编译调试错误"></a>更改源码文件，编译调试错误</h1><ul>
<li>这里可以使用TI官方提供的CAN驱动调试代码,位于以下目录<code>C:\ti\mmwave_sdk_02_01_00_04\packages\ti\drivers\can\test</code></li>
</ul>
<p>拷贝<code>common</code>文件夹下的<code>main.c</code>文件到工程中，替换工程中的c源文件。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511171724492.png" alt="image-20200511171724492"></p>
<ul>
<li>这里可以看到右侧提示未找到头文件，选中工程右键<code>Show Building Setting</code>按下图添加头文件包含路径。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511172037703.png" alt="image-20200511172037703"></p>
<ul>
<li>编译代码，提示<code>&quot;SOC_Moduleld&quot; is undefined</code>。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511172343879.png" alt="image-20200511172343879"></p>
<ul>
<li>选中工程右键<code>Show Building Setting</code>添加<code>Predefined Symbols</code></li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511172709459.png" alt="image-20200511172709459"></p>
<ul>
<li>继续编译，又提示如下错误</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200511173016779.png" alt="image-20200511173016779"></p>
<ul>
<li>选中工程右键<code>Show Building Setting</code>添加<code>File Search Path</code>如下所示</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200512090825536.png" alt="image-20200512090825536"></p>
<ul>
<li>继续编译，出现如下错误，这里是对应cfg配置文件没有做相应修改，将<code>C:\ti\mmwave_sdk_02_01_00_04\packages\ti\drivers\can\test\xwr14xx</code>目录下<code>mss.cfg</code>文件替换过来。这里也可以按照修改建议自己在cfg文件中添加相关声明。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200512091101960.png" alt="image-20200512091101960"></p>
<ul>
<li>继续编译，提示块<code>.MCPILogBuffer</code>没有声明</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200512091639130.png" alt="image-20200512091639130"></p>
<ul>
<li>这里我们可以在<code>.cmd</code>链接文件，这里是<code>IWR14XX.cmd</code>中做声明如下，继续编译已经没有错误了。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200512092041423.png" alt="image-20200512092041423"></p>
<h1 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h1><p>未完待续…</p>
]]></content>
      <categories>
        <category>毫米波雷达学习</category>
      </categories>
      <tags>
        <tag>MmwaveRadar</tag>
      </tags>
  </entry>
  <entry>
    <title>TI-RTOS学习笔记1</title>
    <url>/2020/04/26/RTOS-study-notes1/</url>
    <content><![CDATA[<h1 id="TI-RTOS学习笔记"><a href="#TI-RTOS学习笔记" class="headerlink" title="TI-RTOS学习笔记"></a>TI-RTOS学习笔记</h1><h2 id="RTOS调度机制"><a href="#RTOS调度机制" class="headerlink" title="RTOS调度机制"></a>RTOS调度机制</h2><h3 id="Separate-Process-from-ISR"><a href="#Separate-Process-from-ISR" class="headerlink" title="Separate Process from ISR"></a>Separate Process from ISR</h3><ul>
<li><p>将处理过程从中断程序中剥离出来</p>
<p><strong>为什么这么做？</strong></p>
<ul>
<li>死循环：占用大量硬件资源</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153331676.png" alt="image-20200424153331676"></p>
<ul>
<li><p>基于计时器的中断：会导致中断的遗漏</p>
<a id="more"></a>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153600953.png" alt="image-20200424153537897"></p>
</li>
<li><p>使用嵌套中断：多中断情况下难以宏观调配</p>
</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153537897.png" alt="image-20200424153600953"></p>
<ul>
<li>将中断响应与处理过程分离</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424152208657.png" alt="image-20200424152208657"></p>
<p>将中断响应与中断处理程序分离之后，用户可以通过function的优先级来完成控制，接下来将要执行的功能完全取决于用户为其所设置的优先级。</p>
<h3 id="BIOS调度机制"><a href="#BIOS调度机制" class="headerlink" title="BIOS调度机制"></a>BIOS调度机制</h3><p>三种事件类型</p>
<ul>
<li>Hwi 硬件中断 优先级最高</li>
<li>Swi 软件中断 优先级次之</li>
<li>Idle 闲置事件 优先级最低</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424150844713.png" alt="image-20200424150844713"></p>
<ul>
<li>在多Hwi（Swi）任务中，可以将同类型的事件进一步划定优先级（如优先级10的事件优先于优先级1的事件执行）。Idle类型事件内部不再划分优先级区别。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424151320042.png" alt="image-20200424151320042"></p>
<h3 id="The-Scheduler-–-in-Action"><a href="#The-Scheduler-–-in-Action" class="headerlink" title="The Scheduler – in Action"></a>The Scheduler – in Action</h3><p>​    程序总是从main()函数的开始执行最终也结束于main()的结尾，调用BIOS_start函数。这个函数启动了BIOS 任务调度。这时没有在运行的任务，所以BIOS总是处于最低的优先级属于Idle类事件。如果有函数在Idle线程里，它们会被调用。这与main()函数中在while()循环以外的函数类似， 都是在等待‘事件’的发生（如：中断）。</p>
<p>​    随着时间流逝，Hwi1中断被触发，Hwi1运行并且触发 Swi2，而BIOS总是运行优先级最高的线程，所以等待Hwi1执行，此时Swi2处于Ready状态。（软件中断三种状态：Ready；Running；Inactive）。</p>
<p>​    当Swi2运行中会触发Hwi2，此时Swi2会被Hwi2抢占，CPU执行Hwi2中的post3内容，当Hwi2执行完毕后此时有两个线程处于Ready状态-Swi2与Swi3.在BIOS中，数字越大，优先级越高。所以Swi3会执行并触发Swi1。Swi1变为Ready状态，Swi3仍在执行。</p>
<p>当Swi3执行完毕后，两个进程处于Ready状态，先执行Swi2，然后Swi1。Swi1执行完毕后，系统除了Idle任务外没有其他线程。Idle一直处于等待运行的状态，所以接下来Idle运行，最后程序结束。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424160918210.png" alt="image-20200424162638728"></p>
<h3 id="Adding-Tasks"><a href="#Adding-Tasks" class="headerlink" title="Adding Tasks"></a>Adding Tasks</h3><p>任务：任务意味着可以与其他的任务同时运行，就像运行在while循环里一样一直处于运行状态。产生的数据存放在自己私有的空间里，而且当他们被抢占时，他们进入阻塞或暂停状态，等待一个信号（semaphore）去解除阻塞让其继续运行。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424163115377.png" alt="image-20200424160918210"></p>
<ul>
<li>每个Task都有其自己专属的栈空间用于存储其离开的时的数据，这使得Task可以进行阻塞与暂停操作。这点与Hwi和Swi有非常大的不同，后两者使用的数据存在系统共有栈空间内。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424162638728.png" alt="image-20200424163115377"></p>
<h3 id="TI-RTOS-Kernel-Services-–-Summary"><a href="#TI-RTOS-Kernel-Services-–-Summary" class="headerlink" title="TI-RTOS Kernel Services – Summary"></a>TI-RTOS Kernel Services – Summary</h3><p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424164144448.png" alt="image-20200424164144448"></p>
]]></content>
      <categories>
        <category>TI-RTOS学习笔记</category>
      </categories>
      <tags>
        <tag>TI-RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>TI-RTOS学习笔记2</title>
    <url>/2020/04/26/RTOS-study-notes2/</url>
    <content><![CDATA[<h1 id="TI-RTOS学习笔记"><a href="#TI-RTOS学习笔记" class="headerlink" title="TI-RTOS学习笔记"></a>TI-RTOS学习笔记</h1><h2 id="TI-RTOS-Environment"><a href="#TI-RTOS-Environment" class="headerlink" title="TI-RTOS Environment"></a>TI-RTOS Environment</h2><h3 id="Kernel-APIs-Objects-and-Handles"><a href="#Kernel-APIs-Objects-and-Handles" class="headerlink" title="Kernel APIs, Objects and Handles"></a>Kernel APIs, Objects and Handles</h3><ul>
<li>在代码中，当Swi_post()被调用后，BIOS Scheduler运行然后从Swi对象中抓取它的优先级。然后依据优先级将Swi安排在Swi queue中。当Swi在queue的头部时其准备运行，BIOS将会调用Swi对象(或者称为结构体)中的函数，在这个例子里是Audio_fxn。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424170045248.png" alt="image-20200424164609777"></p>
<a id="more"></a>
<h3 id="Thread-Object-Creation-in-BIOS"><a href="#Thread-Object-Creation-in-BIOS" class="headerlink" title="Thread (Object) Creation in BIOS"></a>Thread (Object) Creation in BIOS</h3><p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424164609777.png" alt="image-20200424170045248"></p>
]]></content>
      <categories>
        <category>TI-RTOS学习笔记</category>
      </categories>
      <tags>
        <tag>TI-RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>IWR1443使用内置config文件</title>
    <url>/2020/04/22/iwr1443insert-config/</url>
    <content><![CDATA[<p>TI为推出的IWR1443毫米波雷达评估板提供了丰富可用的演示demo，这些都需要上电之后下载配置文件，这里经过修改可以将配置文件固化在固件中，使得评估板上电即开始工作。</p>
<ul>
<li><p>不过需要注意的是评估板的芯片版本必须与SDK的版本一致，否则会出现无法下载固件，CCS编译错误等问题。</p>
<p>我目前手头的IWR1443对应的SDK版本为mmwave_sdk_02_01_00_04</p>
<p>对应的demo工具箱版本号为mmwave_industrial_toolbox_3_6_1</p>
<a id="more"></a>
<h2 id="在-mmwave-cli-c中添加CLI的头文件"><a href="#在-mmwave-cli-c中添加CLI的头文件" class="headerlink" title="在 mmwave_cli.c中添加CLI的头文件"></a>在 mmwave_cli.c中添加CLI的头文件</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/utils/cli/include/cli_internal.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_015.png" alt="图片1"></p>
<h2 id="在mmwave-cli-c中添加CLI的结构体"><a href="#在mmwave-cli-c中添加CLI的结构体" class="headerlink" title="在mmwave_cli.c中添加CLI的结构体"></a>在mmwave_cli.c中添加CLI的结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> CLI_MCB      gCLI;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_02.png" alt="图片2"></p>
<h2 id="在main-c文件中添加相应的功能定义"><a href="#在main-c文件中添加相应的功能定义" class="headerlink" title="在main.c文件中添加相应的功能定义"></a>在main.c文件中添加相应的功能定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">MmwDemo_Bypass_CLI</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在”void MmwDemo_initTask(UArg arg0, UArg arg1)”函数中调用MmwDemo_Bypass_CLI()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MmwDemo_Bypass_CLI();</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_03.png" alt="图片3"></p>
<h2 id="在mmwave-cli-c中添加配置信息"><a href="#在mmwave-cli-c中添加配置信息" class="headerlink" title="在mmwave_cli.c中添加配置信息"></a>在mmwave_cli.c中添加配置信息</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_BYPASS 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RADAR_CMD        24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* radarCmdString[MAX_RADAR_CMD] =</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"sensorStop \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"flushCfg \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"dfeDataOutputMode 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"channelCfg 15 7 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"adcCfg 2 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"adcbufCfg 0 1 0 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"profileCfg 0 77 7 7 57.14 0 0 70 1 240 4884 0 0 30 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 0 0 0 0 0 0 0 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 1 1 0 0 0 0 0 4 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 2 2 0 0 0 0 0 2 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"frameCfg 0 2 16 0 33.333 1 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"lowPower 0 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"guiMonitor 1 0 0 0 0 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"cfarCfg 0 2 8 4 3 0 768 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"peakGrouping 1 0 1 1 229 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"multiObjBeamForming 1 0.5 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"clutterRemoval 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"calibDcRangeSig 0 -5 8 256 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"compRangeBiasAndRxChanPhase 0.0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"measureRangeBiasAndRxChanPhase 0 1.5 0.2 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"CQRxSatMonitor 0 3 5 123 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"CQSigImgMonitor 0 119 4 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"analogMonitor 1 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"sensorStart \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">CLI_ByPassApi</span><span class="params">(CLI_Cfg* ptrCLICfg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//uint8_t cmdString[128];</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* tokenizedArgs[CLI_MAX_ARGS];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* ptrCLICommand;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> delimitter[] = <span class="string">" \r\n"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> argIndex;</span><br><span class="line"></span><br><span class="line">   CLI_CmdTableEntry* ptrCLICommandEntry;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> cliStatus;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> index, idx;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint16_t</span> numCLICommands = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Sanity Check: Validate the arguments */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (ptrCLICfg == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Cycle through and determine the number of supported CLI commands: */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; CLI_MAX_CMD; index++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Do we have a valid entry? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ptrCLICfg-&gt;tableEntry[index].cmd == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* NO: This is the last entry */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* YES: Increment the number of CLI commands */</span></span><br><span class="line"></span><br><span class="line">           numCLICommands = numCLICommands + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute All Radar Commands */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; MAX_RADAR_CMD; idx++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Reset all the tokenized arguments: */</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">memset</span> ((<span class="keyword">void</span> *)&amp;tokenizedArgs, <span class="number">0</span>, <span class="keyword">sizeof</span>(tokenizedArgs));</span><br><span class="line"></span><br><span class="line">       argIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       ptrCLICommand = (<span class="keyword">char</span>*)radarCmdString[idx];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Set the CLI status: */</span></span><br><span class="line"></span><br><span class="line">       cliStatus = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* The command has been entered we now tokenize the command message */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Tokenize the arguments: */</span></span><br><span class="line"></span><br><span class="line">           tokenizedArgs[argIndex] = strtok(ptrCLICommand, delimitter);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (tokenizedArgs[argIndex] == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Increment the argument index: */</span></span><br><span class="line"></span><br><span class="line">           argIndex++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (argIndex &gt;= CLI_MAX_ARGS)</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Reset the command string */</span></span><br><span class="line"></span><br><span class="line">           ptrCLICommand = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Were we able to tokenize the CLI command? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (argIndex == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Cycle through all the registered CLI commands: */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; numCLICommands; index++)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           ptrCLICommandEntry = &amp;ptrCLICfg-&gt;tableEntry[index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Do we have a match? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ptrCLICommandEntry-&gt;cmd, tokenizedArgs[<span class="number">0</span>]) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* YES: Pass this to the CLI registered function */</span></span><br><span class="line"></span><br><span class="line">               cliStatus = ptrCLICommandEntry-&gt;cmdHandlerFxn (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (cliStatus == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (<span class="string">"Done\n"</span>);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (<span class="string">"Error %d\n"</span>, cliStatus);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Did we get a matching CLI command? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (index == numCLICommands)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* NO matching command found. Is the mmWave extension enabled? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (ptrCLICfg-&gt;enableMMWaveExtension == <span class="number">1U</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* Yes: Pass this to the mmWave extension handler */</span></span><br><span class="line"></span><br><span class="line">               cliStatus = CLI_MMWaveExtensionHandler (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Was the CLI command found? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (cliStatus == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* No: The command was still not found */</span></span><br><span class="line"></span><br><span class="line">               CLI_write (<span class="string">"'%s' is not recognized as a CLI command\n"</span>, tokenizedArgs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmwDemo_Bypass_CLI</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (CLI_ByPassApi(&amp;gCLI.cfg) != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       System_printf (<span class="string">"Error: Unable to CLI_ByPassApi\n"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译生成bin文件"><a href="#编译生成bin文件" class="headerlink" title="编译生成bin文件"></a>编译生成bin文件</h2><p>在build setting选项中勾选生成bin文件</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E9%85%8D%E7%BD%AE.png" alt="图片4"></p>
]]></content>
      <categories>
        <category>毫米波雷达学习</category>
      </categories>
      <tags>
        <tag>MmwaveRadar</tag>
      </tags>
  </entry>
</search>
