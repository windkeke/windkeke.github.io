<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TI-RTOS学习笔记1</title>
    <url>/2020/04/26/RTOS-study-notes1/</url>
    <content><![CDATA[<h1 id="TI-RTOS学习笔记"><a href="#TI-RTOS学习笔记" class="headerlink" title="TI-RTOS学习笔记"></a>TI-RTOS学习笔记</h1><h2 id="RTOS调度机制"><a href="#RTOS调度机制" class="headerlink" title="RTOS调度机制"></a>RTOS调度机制</h2><h3 id="Separate-Process-from-ISR"><a href="#Separate-Process-from-ISR" class="headerlink" title="Separate Process from ISR"></a>Separate Process from ISR</h3><ul>
<li><p>将处理过程从中断程序中剥离出来</p>
<p><strong>为什么这么做？</strong></p>
<ul>
<li><p>死循环：占用大量硬件资源</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153331676.png" alt="image-20200424153331676"></p>
</li>
<li><p>基于计时器的中断：会导致中断的遗漏</p>
<a id="more"></a>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153600953.png" alt="image-20200424153537897"></p>
</li>
<li><p>使用嵌套中断：多中断情况下难以宏观调配</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153537897.png" alt="image-20200424153600953"></p>
</li>
<li><p>将中断响应与处理过程分离</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424152208657.png" alt="image-20200424152208657"></p>
<p>将中断响应与中断处理程序分离之后，用户可以通过function的优先级来完成控制，接下来将要执行的功能完全取决于用户为其所设置的优先级。</p>
<h3 id="BIOS调度机制"><a href="#BIOS调度机制" class="headerlink" title="BIOS调度机制"></a>BIOS调度机制</h3><p>三种事件类型</p>
<ul>
<li>Hwi 硬件中断 优先级最高</li>
<li>Swi 软件中断 优先级次之</li>
<li>Idle 闲置事件 优先级最低</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424150844713.png" alt="image-20200424150844713"></p>
<ul>
<li>在多Hwi（Swi）任务中，可以将同类型的事件进一步划定优先级（如优先级10的事件优先于优先级1的事件执行）。Idle类型事件内部不再划分优先级区别。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424151320042.png" alt="image-20200424151320042"></p>
<h3 id="The-Scheduler-–-in-Action"><a href="#The-Scheduler-–-in-Action" class="headerlink" title="The Scheduler – in Action"></a>The Scheduler – in Action</h3><p>​    程序总是从main()函数的开始执行最终也结束于main()的结尾，调用BIOS_start函数。这个函数启动了BIOS 任务调度。这时没有在运行的任务，所以BIOS总是处于最低的优先级属于Idle类事件。如果有函数在Idle线程里，它们会被调用。这与main()函数中在while()循环以外的函数类似， 都是在等待‘事件’的发生（如：中断）。</p>
<p>​    随着时间流逝，Hwi1中断被触发，Hwi1运行并且触发 Swi2，而BIOS总是运行优先级最高的线程，所以等待Hwi1执行，此时Swi2处于Ready状态。（软件中断三种状态：Ready；Running；Inactive）。</p>
<p>​    当Swi2运行中会触发Hwi2，此时Swi2会被Hwi2抢占，CPU执行Hwi2中的post3内容，当Hwi2执行完毕后此时有两个线程处于Ready状态-Swi2与Swi3.在BIOS中，数字越大，优先级越高。所以Swi3会执行并触发Swi1。Swi1变为Ready状态，Swi3仍在执行。</p>
<p>当Swi3执行完毕后，两个进程处于Ready状态，先执行Swi2，然后Swi1。Swi1执行完毕后，系统除了Idle任务外没有其他线程。Idle一直处于等待运行的状态，所以接下来Idle运行，最后程序结束。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424163115377.png" alt="image-20200424160918210"></p>
<h3 id="Adding-Tasks"><a href="#Adding-Tasks" class="headerlink" title="Adding Tasks"></a>Adding Tasks</h3><p>任务：任务意味着可以与其他的任务同时运行，就像运行在while循环里一样一直处于运行状态。产生的数据存放在自己私有的空间里，而且当他们被抢占时，他们进入阻塞或暂停状态，等待一个信号（semaphore）去解除阻塞让其继续运行。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424160918210.png" alt="image-20200424162638728"></p>
<ul>
<li>每个Task都有其自己专属的栈空间用于存储其离开的时的数据，这使得Task可以进行阻塞与暂停操作。这点与Hwi和Swi有非常大的不同，后两者使用的数据存在系统共有栈空间内。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424162638728.png" alt="image-20200424163115377"></p>
<h3 id="TI-RTOS-Kernel-Services-–-Summary"><a href="#TI-RTOS-Kernel-Services-–-Summary" class="headerlink" title="TI-RTOS Kernel Services – Summary"></a>TI-RTOS Kernel Services – Summary</h3><p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424164144448.png" alt="image-20200424164144448"></p>
]]></content>
      <categories>
        <category>TI-RTOS学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>IWR1443使用内置config文件</title>
    <url>/2020/04/22/iwr1443insert-config/</url>
    <content><![CDATA[<p>TI为推出的IWR1443毫米波雷达评估板提供了丰富可用的演示demo，这些都需要上电之后下载配置文件，这里经过修改可以将配置文件固化在固件中，使得评估板上电即开始工作。</p>
<ul>
<li><p>不过需要注意的是评估板的芯片版本必须与SDK的版本一致，否则会出现无法下载固件，CCS编译错误等问题。</p>
<p>我目前手头的IWR1443对应的SDK版本为mmwave_sdk_02_01_00_04</p>
<p>对应的demo工具箱版本号为mmwave_industrial_toolbox_3_6_1</p>
<a id="more"></a>
<h2 id="在-mmwave-cli-c中添加CLI的头文件"><a href="#在-mmwave-cli-c中添加CLI的头文件" class="headerlink" title="在 mmwave_cli.c中添加CLI的头文件"></a>在 mmwave_cli.c中添加CLI的头文件</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;ti&#x2F;utils&#x2F;cli&#x2F;include&#x2F;cli_internal.h&gt;</span><br></pre></td></tr></table></figure>


<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_015.png" alt="图片1"></p>
<h2 id="在mmwave-cli-c中添加CLI的结构体"><a href="#在mmwave-cli-c中添加CLI的结构体" class="headerlink" title="在mmwave_cli.c中添加CLI的结构体"></a>在mmwave_cli.c中添加CLI的结构体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern CLI_MCB      gCLI;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_02.png" alt="图片2"></p>
<h2 id="在main-c文件中添加相应的功能定义"><a href="#在main-c文件中添加相应的功能定义" class="headerlink" title="在main.c文件中添加相应的功能定义"></a>在main.c文件中添加相应的功能定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern void MmwDemo_Bypass_CLI (void);</span><br></pre></td></tr></table></figure>

<ul>
<li>在”void MmwDemo_initTask(UArg arg0, UArg arg1)”函数中调用MmwDemo_Bypass_CLI()函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MmwDemo_Bypass_CLI();</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_03.png" alt="图片3"></p>
<h2 id="在mmwave-cli-c中添加配置信息"><a href="#在mmwave-cli-c中添加配置信息" class="headerlink" title="在mmwave_cli.c中添加配置信息"></a>在mmwave_cli.c中添加配置信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define CLI_BYPASS 1</span><br><span class="line"></span><br><span class="line">#define MAX_RADAR_CMD        24</span><br><span class="line"></span><br><span class="line">uint8_t* radarCmdString[MAX_RADAR_CMD] &#x3D;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &#123;&quot;sensorStop \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;flushCfg \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;dfeDataOutputMode 1 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;channelCfg 15 7 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;adcCfg 2 1 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;adcbufCfg 0 1 0 1 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;profileCfg 0 77 7 7 57.14 0 0 70 1 240 4884 0 0 30 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;chirpCfg 0 0 0 0 0 0 0 1 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;chirpCfg 1 1 0 0 0 0 0 4 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;chirpCfg 2 2 0 0 0 0 0 2 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;frameCfg 0 2 16 0 33.333 1 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;lowPower 0 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;guiMonitor 1 0 0 0 0 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;cfarCfg 0 2 8 4 3 0 768 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;peakGrouping 1 0 1 1 229 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;multiObjBeamForming 1 0.5 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;clutterRemoval 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;calibDcRangeSig 0 -5 8 256 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;compRangeBiasAndRxChanPhase 0.0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;measureRangeBiasAndRxChanPhase 0 1.5 0.2 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;CQRxSatMonitor 0 3 5 123 0 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;CQSigImgMonitor 0 119 4 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;analogMonitor 1 1 \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;&quot;sensorStart \r\n&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int32_t CLI_ByPassApi(CLI_Cfg* ptrCLICfg)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;uint8_t cmdString[128];</span><br><span class="line"></span><br><span class="line">   char* tokenizedArgs[CLI_MAX_ARGS];</span><br><span class="line"></span><br><span class="line">   char* ptrCLICommand;</span><br><span class="line"></span><br><span class="line">   char delimitter[] &#x3D; &quot; \r\n&quot;;</span><br><span class="line"></span><br><span class="line">   uint32_t argIndex;</span><br><span class="line"></span><br><span class="line">   CLI_CmdTableEntry* ptrCLICommandEntry;</span><br><span class="line"></span><br><span class="line">   int32_t cliStatus;</span><br><span class="line"></span><br><span class="line">   uint32_t index, idx;</span><br><span class="line"></span><br><span class="line">   uint16_t numCLICommands &#x3D; 0U;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;* Sanity Check: Validate the arguments *&#x2F;</span><br><span class="line"></span><br><span class="line">   if (ptrCLICfg &#x3D;&#x3D; NULL)</span><br><span class="line"></span><br><span class="line">   return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;* Cycle through and determine the number of supported CLI commands: *&#x2F;</span><br><span class="line"></span><br><span class="line">   for (index &#x3D; 0; index &lt; CLI_MAX_CMD; index++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;* Do we have a valid entry? *&#x2F;</span><br><span class="line"></span><br><span class="line">       if (ptrCLICfg-&gt;tableEntry[index].cmd &#x3D;&#x3D; NULL)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;* NO: This is the last entry *&#x2F;</span><br><span class="line"></span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       else</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;* YES: Increment the number of CLI commands *&#x2F;</span><br><span class="line"></span><br><span class="line">           numCLICommands &#x3D; numCLICommands + 1;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;* Execute All Radar Commands *&#x2F;</span><br><span class="line"></span><br><span class="line">   for (idx &#x3D; 0; idx &lt; MAX_RADAR_CMD; idx++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;* Reset all the tokenized arguments: *&#x2F;</span><br><span class="line"></span><br><span class="line">       memset ((void *)&amp;tokenizedArgs, 0, sizeof(tokenizedArgs));</span><br><span class="line"></span><br><span class="line">       argIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       ptrCLICommand &#x3D; (char*)radarCmdString[idx];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;* Set the CLI status: *&#x2F;</span><br><span class="line"></span><br><span class="line">       cliStatus &#x3D; -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;* The command has been entered we now tokenize the command message *&#x2F;</span><br><span class="line"></span><br><span class="line">       while (1)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;* Tokenize the arguments: *&#x2F;</span><br><span class="line"></span><br><span class="line">           tokenizedArgs[argIndex] &#x3D; strtok(ptrCLICommand, delimitter);</span><br><span class="line"></span><br><span class="line">           if (tokenizedArgs[argIndex] &#x3D;&#x3D; NULL)</span><br><span class="line"></span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#x2F;* Increment the argument index: *&#x2F;</span><br><span class="line"></span><br><span class="line">           argIndex++;</span><br><span class="line"></span><br><span class="line">           if (argIndex &gt;&#x3D; CLI_MAX_ARGS)</span><br><span class="line"></span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#x2F;* Reset the command string *&#x2F;</span><br><span class="line"></span><br><span class="line">           ptrCLICommand &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;* Were we able to tokenize the CLI command? *&#x2F;</span><br><span class="line"></span><br><span class="line">       if (argIndex &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line">           continue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;* Cycle through all the registered CLI commands: *&#x2F;</span><br><span class="line"></span><br><span class="line">       for (index &#x3D; 0; index &lt; numCLICommands; index++)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           ptrCLICommandEntry &#x3D; &amp;ptrCLICfg-&gt;tableEntry[index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#x2F;* Do we have a match? *&#x2F;</span><br><span class="line"></span><br><span class="line">           if (strcmp(ptrCLICommandEntry-&gt;cmd, tokenizedArgs[0]) &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               &#x2F;* YES: Pass this to the CLI registered function *&#x2F;</span><br><span class="line"></span><br><span class="line">               cliStatus &#x3D; ptrCLICommandEntry-&gt;cmdHandlerFxn (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">               if (cliStatus &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (&quot;Done\n&quot;);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               else</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (&quot;Error %d\n&quot;, cliStatus);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;* Did we get a matching CLI command? *&#x2F;</span><br><span class="line"></span><br><span class="line">       if (index &#x3D;&#x3D; numCLICommands)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;* NO matching command found. Is the mmWave extension enabled? *&#x2F;</span><br><span class="line"></span><br><span class="line">           if (ptrCLICfg-&gt;enableMMWaveExtension &#x3D;&#x3D; 1U)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               &#x2F;* Yes: Pass this to the mmWave extension handler *&#x2F;</span><br><span class="line"></span><br><span class="line">               cliStatus &#x3D; CLI_MMWaveExtensionHandler (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#x2F;* Was the CLI command found? *&#x2F;</span><br><span class="line"></span><br><span class="line">           if (cliStatus &#x3D;&#x3D; -1)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               &#x2F;* No: The command was still not found *&#x2F;</span><br><span class="line"></span><br><span class="line">               CLI_write (&quot;&#39;%s&#39; is not recognized as a CLI command\n&quot;, tokenizedArgs[0]);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MmwDemo_Bypass_CLI (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   if (CLI_ByPassApi(&amp;gCLI.cfg) !&#x3D; 0)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       System_printf (&quot;Error: Unable to CLI_ByPassApi\n&quot;);</span><br><span class="line"></span><br><span class="line">       return;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译生成bin文件"><a href="#编译生成bin文件" class="headerlink" title="编译生成bin文件"></a>编译生成bin文件</h2><p>在build setting选项中勾选生成bin文件</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E9%85%8D%E7%BD%AE.png" alt="图片4"></p>
]]></content>
      <categories>
        <category>毫米波雷达学习</category>
      </categories>
      <tags>
        <tag>MmwaveRadar</tag>
      </tags>
  </entry>
</search>
