<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TI-RTOS学习笔记1</title>
    <url>/2020/04/26/RTOS-study-notes1/</url>
    <content><![CDATA[<h1 id="TI-RTOS学习笔记"><a href="#TI-RTOS学习笔记" class="headerlink" title="TI-RTOS学习笔记"></a>TI-RTOS学习笔记</h1><h2 id="RTOS调度机制"><a href="#RTOS调度机制" class="headerlink" title="RTOS调度机制"></a>RTOS调度机制</h2><h3 id="Separate-Process-from-ISR"><a href="#Separate-Process-from-ISR" class="headerlink" title="Separate Process from ISR"></a>Separate Process from ISR</h3><ul>
<li><p>将处理过程从中断程序中剥离出来</p>
<p><strong>为什么这么做？</strong></p>
<ul>
<li>死循环：占用大量硬件资源</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153331676.png" alt="image-20200424153331676"></p>
<ul>
<li><p>基于计时器的中断：会导致中断的遗漏</p>
<a id="more"></a>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153600953.png" alt="image-20200424153537897"></p>
</li>
<li><p>使用嵌套中断：多中断情况下难以宏观调配</p>
</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424153537897.png" alt="image-20200424153600953"></p>
<ul>
<li>将中断响应与处理过程分离</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424152208657.png" alt="image-20200424152208657"></p>
<p>将中断响应与中断处理程序分离之后，用户可以通过function的优先级来完成控制，接下来将要执行的功能完全取决于用户为其所设置的优先级。</p>
<h3 id="BIOS调度机制"><a href="#BIOS调度机制" class="headerlink" title="BIOS调度机制"></a>BIOS调度机制</h3><p>三种事件类型</p>
<ul>
<li>Hwi 硬件中断 优先级最高</li>
<li>Swi 软件中断 优先级次之</li>
<li>Idle 闲置事件 优先级最低</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424150844713.png" alt="image-20200424150844713"></p>
<ul>
<li>在多Hwi（Swi）任务中，可以将同类型的事件进一步划定优先级（如优先级10的事件优先于优先级1的事件执行）。Idle类型事件内部不再划分优先级区别。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424151320042.png" alt="image-20200424151320042"></p>
<h3 id="The-Scheduler-–-in-Action"><a href="#The-Scheduler-–-in-Action" class="headerlink" title="The Scheduler – in Action"></a>The Scheduler – in Action</h3><p>​    程序总是从main()函数的开始执行最终也结束于main()的结尾，调用BIOS_start函数。这个函数启动了BIOS 任务调度。这时没有在运行的任务，所以BIOS总是处于最低的优先级属于Idle类事件。如果有函数在Idle线程里，它们会被调用。这与main()函数中在while()循环以外的函数类似， 都是在等待‘事件’的发生（如：中断）。</p>
<p>​    随着时间流逝，Hwi1中断被触发，Hwi1运行并且触发 Swi2，而BIOS总是运行优先级最高的线程，所以等待Hwi1执行，此时Swi2处于Ready状态。（软件中断三种状态：Ready；Running；Inactive）。</p>
<p>​    当Swi2运行中会触发Hwi2，此时Swi2会被Hwi2抢占，CPU执行Hwi2中的post3内容，当Hwi2执行完毕后此时有两个线程处于Ready状态-Swi2与Swi3.在BIOS中，数字越大，优先级越高。所以Swi3会执行并触发Swi1。Swi1变为Ready状态，Swi3仍在执行。</p>
<p>当Swi3执行完毕后，两个进程处于Ready状态，先执行Swi2，然后Swi1。Swi1执行完毕后，系统除了Idle任务外没有其他线程。Idle一直处于等待运行的状态，所以接下来Idle运行，最后程序结束。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424160918210.png" alt="image-20200424162638728"></p>
<h3 id="Adding-Tasks"><a href="#Adding-Tasks" class="headerlink" title="Adding Tasks"></a>Adding Tasks</h3><p>任务：任务意味着可以与其他的任务同时运行，就像运行在while循环里一样一直处于运行状态。产生的数据存放在自己私有的空间里，而且当他们被抢占时，他们进入阻塞或暂停状态，等待一个信号（semaphore）去解除阻塞让其继续运行。</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424163115377.png" alt="image-20200424160918210"></p>
<ul>
<li>每个Task都有其自己专属的栈空间用于存储其离开的时的数据，这使得Task可以进行阻塞与暂停操作。这点与Hwi和Swi有非常大的不同，后两者使用的数据存在系统共有栈空间内。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424162638728.png" alt="image-20200424163115377"></p>
<h3 id="TI-RTOS-Kernel-Services-–-Summary"><a href="#TI-RTOS-Kernel-Services-–-Summary" class="headerlink" title="TI-RTOS Kernel Services – Summary"></a>TI-RTOS Kernel Services – Summary</h3><p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424164144448.png" alt="image-20200424164144448"></p>
]]></content>
      <categories>
        <category>TI-RTOS学习笔记</category>
      </categories>
      <tags>
        <tag>TI-RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>TI-RTOS学习笔记2</title>
    <url>/2020/04/26/RTOS-study-notes2/</url>
    <content><![CDATA[<h1 id="TI-RTOS学习笔记"><a href="#TI-RTOS学习笔记" class="headerlink" title="TI-RTOS学习笔记"></a>TI-RTOS学习笔记</h1><h2 id="TI-RTOS-Environment"><a href="#TI-RTOS-Environment" class="headerlink" title="TI-RTOS Environment"></a>TI-RTOS Environment</h2><h3 id="Kernel-APIs-Objects-and-Handles"><a href="#Kernel-APIs-Objects-and-Handles" class="headerlink" title="Kernel APIs, Objects and Handles"></a>Kernel APIs, Objects and Handles</h3><ul>
<li>在代码中，当Swi_post()被调用后，BIOS Scheduler运行然后从Swi对象中抓取它的优先级。然后依据优先级将Swi安排在Swi queue中。当Swi在queue的头部时其准备运行，BIOS将会调用Swi对象(或者称为结构体)中的函数，在这个例子里是Audio_fxn。</li>
</ul>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424170045248.png" alt="image-20200424164609777"></p>
<a id="more"></a>
<h3 id="Thread-Object-Creation-in-BIOS"><a href="#Thread-Object-Creation-in-BIOS" class="headerlink" title="Thread (Object) Creation in BIOS"></a>Thread (Object) Creation in BIOS</h3><p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/image-20200424164609777.png" alt="image-20200424170045248"></p>
]]></content>
      <categories>
        <category>TI-RTOS学习笔记</category>
      </categories>
      <tags>
        <tag>TI-RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>IWR1443使用内置config文件</title>
    <url>/2020/04/22/iwr1443insert-config/</url>
    <content><![CDATA[<p>TI为推出的IWR1443毫米波雷达评估板提供了丰富可用的演示demo，这些都需要上电之后下载配置文件，这里经过修改可以将配置文件固化在固件中，使得评估板上电即开始工作。</p>
<ul>
<li><p>不过需要注意的是评估板的芯片版本必须与SDK的版本一致，否则会出现无法下载固件，CCS编译错误等问题。</p>
<p>我目前手头的IWR1443对应的SDK版本为mmwave_sdk_02_01_00_04</p>
<p>对应的demo工具箱版本号为mmwave_industrial_toolbox_3_6_1</p>
<a id="more"></a>
<h2 id="在-mmwave-cli-c中添加CLI的头文件"><a href="#在-mmwave-cli-c中添加CLI的头文件" class="headerlink" title="在 mmwave_cli.c中添加CLI的头文件"></a>在 mmwave_cli.c中添加CLI的头文件</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/utils/cli/include/cli_internal.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_015.png" alt="图片1"></p>
<h2 id="在mmwave-cli-c中添加CLI的结构体"><a href="#在mmwave-cli-c中添加CLI的结构体" class="headerlink" title="在mmwave_cli.c中添加CLI的结构体"></a>在mmwave_cli.c中添加CLI的结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> CLI_MCB      gCLI;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_02.png" alt="图片2"></p>
<h2 id="在main-c文件中添加相应的功能定义"><a href="#在main-c文件中添加相应的功能定义" class="headerlink" title="在main.c文件中添加相应的功能定义"></a>在main.c文件中添加相应的功能定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">MmwDemo_Bypass_CLI</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在”void MmwDemo_initTask(UArg arg0, UArg arg1)”函数中调用MmwDemo_Bypass_CLI()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MmwDemo_Bypass_CLI();</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_03.png" alt="图片3"></p>
<h2 id="在mmwave-cli-c中添加配置信息"><a href="#在mmwave-cli-c中添加配置信息" class="headerlink" title="在mmwave_cli.c中添加配置信息"></a>在mmwave_cli.c中添加配置信息</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_BYPASS 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_RADAR_CMD        24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* radarCmdString[MAX_RADAR_CMD] =</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"sensorStop \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"flushCfg \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"dfeDataOutputMode 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"channelCfg 15 7 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"adcCfg 2 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"adcbufCfg 0 1 0 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"profileCfg 0 77 7 7 57.14 0 0 70 1 240 4884 0 0 30 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 0 0 0 0 0 0 0 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 1 1 0 0 0 0 0 4 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"chirpCfg 2 2 0 0 0 0 0 2 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"frameCfg 0 2 16 0 33.333 1 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"lowPower 0 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"guiMonitor 1 0 0 0 0 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"cfarCfg 0 2 8 4 3 0 768 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"peakGrouping 1 0 1 1 229 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"multiObjBeamForming 1 0.5 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"clutterRemoval 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"calibDcRangeSig 0 -5 8 256 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"compRangeBiasAndRxChanPhase 0.0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"measureRangeBiasAndRxChanPhase 0 1.5 0.2 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"CQRxSatMonitor 0 3 5 123 0 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"CQSigImgMonitor 0 119 4 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"analogMonitor 1 1 \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">   &#123;<span class="string">"sensorStart \r\n"</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">CLI_ByPassApi</span><span class="params">(CLI_Cfg* ptrCLICfg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//uint8_t cmdString[128];</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* tokenizedArgs[CLI_MAX_ARGS];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* ptrCLICommand;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> delimitter[] = <span class="string">" \r\n"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> argIndex;</span><br><span class="line"></span><br><span class="line">   CLI_CmdTableEntry* ptrCLICommandEntry;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> cliStatus;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> index, idx;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint16_t</span> numCLICommands = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Sanity Check: Validate the arguments */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (ptrCLICfg == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Cycle through and determine the number of supported CLI commands: */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; CLI_MAX_CMD; index++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Do we have a valid entry? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ptrCLICfg-&gt;tableEntry[index].cmd == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* NO: This is the last entry */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* YES: Increment the number of CLI commands */</span></span><br><span class="line"></span><br><span class="line">           numCLICommands = numCLICommands + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute All Radar Commands */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; MAX_RADAR_CMD; idx++)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Reset all the tokenized arguments: */</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">memset</span> ((<span class="keyword">void</span> *)&amp;tokenizedArgs, <span class="number">0</span>, <span class="keyword">sizeof</span>(tokenizedArgs));</span><br><span class="line"></span><br><span class="line">       argIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       ptrCLICommand = (<span class="keyword">char</span>*)radarCmdString[idx];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Set the CLI status: */</span></span><br><span class="line"></span><br><span class="line">       cliStatus = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* The command has been entered we now tokenize the command message */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Tokenize the arguments: */</span></span><br><span class="line"></span><br><span class="line">           tokenizedArgs[argIndex] = strtok(ptrCLICommand, delimitter);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (tokenizedArgs[argIndex] == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Increment the argument index: */</span></span><br><span class="line"></span><br><span class="line">           argIndex++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (argIndex &gt;= CLI_MAX_ARGS)</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Reset the command string */</span></span><br><span class="line"></span><br><span class="line">           ptrCLICommand = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Were we able to tokenize the CLI command? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (argIndex == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Cycle through all the registered CLI commands: */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; numCLICommands; index++)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           ptrCLICommandEntry = &amp;ptrCLICfg-&gt;tableEntry[index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Do we have a match? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ptrCLICommandEntry-&gt;cmd, tokenizedArgs[<span class="number">0</span>]) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* YES: Pass this to the CLI registered function */</span></span><br><span class="line"></span><br><span class="line">               cliStatus = ptrCLICommandEntry-&gt;cmdHandlerFxn (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (cliStatus == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (<span class="string">"Done\n"</span>);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                   CLI_write (<span class="string">"Error %d\n"</span>, cliStatus);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Did we get a matching CLI command? */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (index == numCLICommands)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* NO matching command found. Is the mmWave extension enabled? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (ptrCLICfg-&gt;enableMMWaveExtension == <span class="number">1U</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* Yes: Pass this to the mmWave extension handler */</span></span><br><span class="line"></span><br><span class="line">               cliStatus = CLI_MMWaveExtensionHandler (argIndex, tokenizedArgs);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Was the CLI command found? */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (cliStatus == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* No: The command was still not found */</span></span><br><span class="line"></span><br><span class="line">               CLI_write (<span class="string">"'%s' is not recognized as a CLI command\n"</span>, tokenizedArgs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmwDemo_Bypass_CLI</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (CLI_ByPassApi(&amp;gCLI.cfg) != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       System_printf (<span class="string">"Error: Unable to CLI_ByPassApi\n"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译生成bin文件"><a href="#编译生成bin文件" class="headerlink" title="编译生成bin文件"></a>编译生成bin文件</h2><p>在build setting选项中勾选生成bin文件</p>
<p><img src="https://blog-1301937525.cos.ap-beijing.myqcloud.com/blog_image/iwr1443insert-config/%E9%85%8D%E7%BD%AE.png" alt="图片4"></p>
]]></content>
      <categories>
        <category>毫米波雷达学习</category>
      </categories>
      <tags>
        <tag>MmwaveRadar</tag>
      </tags>
  </entry>
</search>
